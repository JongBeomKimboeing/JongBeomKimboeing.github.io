---
layout: post
title: Machine Learning Basis
description: "Machine Learning Basis"
modified: 2020-06-28
tags: [Machine Learning]
categories: [Machine Learning]
---

# Linear Algebra basis

<br>
<br>

## 1. 스칼라와 벡터
- 스칼라: 방향이 없고 크기만 존재하는 양
- 벡터: 방향과 크기가 존재하는 양

<br>
<br>
<br>

## 2. 벡터 공간 / 내적
<br>

### 1) Norm

Norm: n차원 벡터 x = (x1, x2, ... ,x3)에 대해<br>
Norm ||x|| = root(x1^2 + x2^2 + ... +xn^2)이다.<br>
<br>
즉, norm은 원점 o 에서 점 (x1, x2, ... ,xn) 까지 이르는 거리<br>
<br>

norm ||x|| = 1 일 경우<br>
2차원 -> 반지름이 1인 원<br>
3차원 -> 반지름이 1인 구<br>
4차원 -> 반지름이 1인 hyper 구<br>

<br>
<br>

### 2) 내적
<br>

-> dot product<br>
차원이 다른 두 벡터의 내적은 불가하다.<br>
x=(2,3) y=(1,4,2) -> x는 2차원, y는 3차원이므로 내적이 불가하다.<br>

### 3) 외적

-> cross product

<br>
<br>
<br>


## 3. 행렬 (matrix)
실수를 직사각형 모양으로 배열한 것

<br>

### 1) 행렬의 연산

#### 1)) 행렬의 덧셈과 뺄
-> 같은 차원을 가진 행렬끼리만 더하거나 뺄 수 있다.
<br>

#### 2)) 행렬의 곱셈
-> 행렬끼리 곱할 때는 차원을 주의해야 한다.
<br>

ex)<br>
a*b인 경우<br>
a는 (3,2), b는 (2,3)의 차원을 가질 경우<br>
a의 뒤차원과 b의 앞차원이 같으므로 행렬 곱이 가능하며,<br>
a의 앞차원과 b의 뒤차원에 의해 연산 결과의 차원이 결정된다. -> (3,3)이 결과적으로 나온다. <br>
<br>
단, b*a는 연산이 불가하다.<br>

<br>
<br>

### 2) 전치행렬 (Transpose)
전치행렬은 원행렬의 행과 열을 뒤바꾼 행렬이다.

<pre>
A = 1 2 -1
    4 3 0

A transpose = 1 4
              2 3
             -1 0

4를 예시로 
A에서 4는 (2,1) 이다
A transpose는 (1,2)이다.
</pre>


<br>
<br>
<br>
<br>

# Numpy 소개 및 실습
<br>
<br>

## 1. 행렬 만들기
<br>

```python
# 행렬 만들기
import numpy as np
A = np.array([[1,2],
               [3,4]])
print(A)
'''
[[1 2]
 [3 4]]
 
-> 안쪽 []은 행을 표현하고, 각각의 행은 열을 갖는다.
'''
```

<br>
<br>
<br>

## 2. 행렬의 연산
<br>

### 1) 기본적인 행렬 연산
<br>

```python
# 행렬의 연산
A = np.array([[1,2],
               [3,4]])
print(A*3)
'''
[[ 3  6]
 [ 9 12]]
'''
print(A+A)
'''
[[2 4]
 [6 8]]
'''
print(A-A)
'''
[[0 0]
 [0 0]]
'''

```

<br>

### 2) element-wise operation
<br>

```python
A = np.array([[1,2],
               [3,4]])
print(A**2)
'''
-> A*A의 연산

[[ 1  4]
 [ 9 16]]
'''

A = np.array([[1,2],
               [3,4]])
print(A*A)
'''
-> A^2과 같은 결과가 나옴을 볼 수 있다.
(element wise 곱)
[[ 1  4]
 [ 9 16]]
'''

A = np.array([[1,2],
               [3,4]])
print(3**A)
'''
3^A -> 선형대수학에서는 존재하지 않음
각각의 A 값에 대해서 3에 제곱승을 한다.
[[ 3  9]
 [27 81]]
'''
```

<br>

### 3) 행렬 곱셈
<br>

- 행렬의 내적

```python
x = np.array([[1,2],[3,4]])
y = np.array([[3,4],[3,2]])

print(np.dot(x,y))
'''
행렬의 내적
[[ 9  8]
 [21 20]]
'''
```

<br>

- 행렬의 element-wise 곱

```python
x = np.array([[1,2],[3,4]])
y = np.array([[3,4],[3,2]])

print(x*y)
'''
행렬의 element-wise 곱
[[3 8]
 [9 8]]
'''
```

<br>

### 4) numpy array 비교연산
<br>

```python
a = np.array([1,2,3,4])
b = np.array([4,2,2,4])

# 비교연산을 통해 array 내의 값을 빠르게 비교 가능하다.

print(a == b) # [False  True False  True]
print(a > b) # [False False  True False]
```


<br>

### 5) numpy array 논리연산
<br>

```python
a = np.array([1,1,0,0], dtype=bool)
print(a) # [ True  True False False]
b = np.array([1,0,1,0], dtype=bool)
print(b) # [ True False  True False]

print(np.logical_or(a,b))
# [ True  True  True False]
print(np.logical_and(a,b))
# [ True False False False]
print(np.logical_xor(a,b))
# [False  True  True False]
print(np.logical_not(a))
# [False False  True  True]
```

<br>

### 6) numpy array Reductions
-> reduction: 어떤 numpy array가 있을 때 하나의 스칼라 값으로 만들어주는 연산의 모임 <br>

<br>

```python
a = np.array([1,2,3,4,5])

print(np.sum(a))
# 15
print(a.sum())
# 15

print(a.min()) # array에서 가장 작은 값
# 1
print(a.max()) # array에서 가장 큰 값
# 5
print(a.argmin()) # array에서 가장 작은 값의 위치(인덱스)
# 0
print(a.argmax()) # array에서 가장 큰 값의 위치(인덱스)
# 4
```


<br>

### 7) numpy array Logical Reductions
-> numpy array가 모두 boolean 으로 이루어져 있을 때 하나의 boolean 값으로 연산 결과를 냄 <br>
<br>

- all: Array 내의 모든 값이 True 인가?
- any: Array 내의 값이 하나라도 True 인가?

<br>

```python
a = np.array([True, True, True])
b = np.array([True, True, False])

print(np.all(a))
# True
print(np.all(b))
# False
print(np.any(a))
# True
print(np.any(b))
# True
```

<br>

### 8) numpy array Statical Reductions
<br>

```python
x = np.array([1,2,3,1])

print(np.mean(x)) # 평균값
# 1.75
print(np.median(x))
# 중간값 -> array를 오름차순으로 나열했을 때의 중간값 여기서는 1,1,2,3이므로 원소가 짝수개 이므로 (1+2)/2
# 1.5
print(np.std(x)) # 표준편차 -> array 안의 수가 얼마나 분산돼 있는가
# 0.82915619758885
```

<br>
<br>
<br>

## 3. Numpy 예제 문제

<br>
<br>

### 1) Numpy 행렬 만들기

```python
import numpy as np

def main():
    print(matrix_tutorial())

def matrix_tutorial():
    # Create the matrix A here...
    A = np.array([[1,4,5,8],
                  [2,1,7,3],
                  [5,4,5,9]])
    return A

if __name__ == "__main__":
    main()
```

<br>
<br>

### 2) Numpy 행렬 분산 구하기

```python
import numpy as np

def main():
    print(matrix_tutorial())

def matrix_tutorial():
    A = np.array([[1, 4, 5, 8], [2, 1, 7, 3], [5, 4, 5, 9]])
    A = A / np.sum(A)
    # 아래 코드를 작성하세요.

    return np.var(A)

if __name__ == "__main__":
    main()
```

<br>
<br>

### 3) 전치행렬 구하기

- 예외처리와 여러 값 입력에 주의하자.

```python
import numpy as np

def main():
    A = get_matrix()
    print(matrix_tutorial(A))

def get_matrix():
    mat = []
    [n, m] = [int(x) for x in input().strip().split(" ")] # 행과 열 입력 받기 (split을 통해 두 값을 구분)
    # input은 엔터치면 끝난다.
    for i in range(n):
        row = [int(x) for x in input().strip().split(" ")]
        mat.append(row)

    return np.array(mat)

def matrix_tutorial(A):

    B = np.transpose(A) # 전치행렬 # A.T 로 전치행렬 만들 수 있다.
    
    # 예외처리 숙지!!
    try:
        C = np.linalg.inv(B)# 역행렬

    except np.linalg.LinAlgError:
        return "not invertible"
    return np.sum(C > 0)


if __name__ == "__main__":
    main()
```



### 4) 벡터 연산과 numpy로 그림 그리기

- norm 을 이용하여 그림을 그린다.

<br>
<br>

```python
import matplotlib.pyplot as plt
import numpy as np

def circle(P):
    return np.linalg.norm(P) -1
# 위의 그림을 그리는 방식을 생각하면, 정확히 원 위에 있는 점들에 대해서 circle(P) 은 0을 가져야 합니다.
# x^2 + y^2 -1 = 0을 만족시키는 그래프

def diamond(P):
    return np.abs(P[0]) + np.abs(P[1]) -1
# |x| + |y| - 1 =0을 만족시키는 그래프


def smile(P):
    def left_eye(P):
        eye_pos = P - np.array([-0.5, 0.5])
        return np.sqrt(np.sum(eye_pos * eye_pos)) - 0.1

    def right_eye(P):
        eye_pos = P - np.array([0.5, 0.5])
        return np.sqrt(np.sum(eye_pos * eye_pos)) - 0.1

    def mouth(P):
        if P[1] < 0:
            return np.sqrt(np.sum(P * P)) - 0.7
        else:
            return 1

def checker(P, shape, tolerence):
    return abs(shape(P)) < tolerence

def sample(num_points, xrange, yrange, shape, tolerence):
    accepted_points = []
    rejected_points = []

    for i in range(num_points):
        x = np.random.random() * (xrange[1] - xrange[0]) - xrange[0]
        # (xrange[1] - xrange[0])= 기울기, np.random.random()= x, xrange[0]= b  -> 이를 통해 위치선정
        # np.random.random() -> 0 ~ 1사이의 수를 반환
        y = np.random.random() * (yrange[1] - yrange[0]) - xrange[0]

        P = np.array([x, y])

        if(checker(P, shape, tolerence)):
            accepted_points.append(P)
        else:
            rejected_points.append(P)
    return np.array(accepted_points), np.array(rejected_points)

xrange = [-1.5, 1.5]
yrange = [-1.5, 1.5]

accepted_points, rejected_points = sample(100000, xrange, yrange, diamond, 0.005)
plt.figure(figsize=(xrange[1]-xrange[0], yrange[1]-yrange[0]), dpi=150)

plt.scatter(rejected_points[:,0], rejected_points[:,1], c='lightgray', s=0.005) # s= 점의 크기
plt.scatter(accepted_points[:,0], accepted_points[:,1], c='black', s=1)

plt.show()
```











































































